#!/usr/bin/env node
/**
 * Auto-generates Storybook stories from *.examples.ts[x] files in packages/ui.
 * Each examples file should export:
 *  - storyMeta: { componentName: string; title?: string; decorators?: Decorator[]; parameters?: object }
 *  - storyExamples: Record<string, StoryObj> (args/render/argTypes/etc.)
 *
 * Stories are emitted to .rnstorybook/stories/auto and picked up by Storybook.
 */
/* eslint-disable no-console */
const fs = require('fs');
const path = require('path');
const ts = require('typescript');

const UI_NATIVE_ROOT = path.resolve(__dirname, '../../../packages/ui/src/native');
const OUTPUT_ROOT = path.resolve(__dirname, './stories/auto');
const PACKAGE_PREFIX = '@studio/ui';

const EXAMPLE_EXTENSIONS = new Set(['.ts', '.tsx']);

function findExampleFiles(dir) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  const files = [];
  for (const entry of entries) {
    const resolved = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      files.push(...findExampleFiles(resolved));
      continue;
    }
    const ext = path.extname(entry.name);
    if (!EXAMPLE_EXTENSIONS.has(ext)) continue;
    if (entry.name.endsWith('.examples.ts') || entry.name.endsWith('.examples.tsx')) {
      files.push(resolved);
    }
  }
  return files;
}

function unwrapInitializer(node) {
  let current = node;
  // Peel off "as const", satisfies, and parentheses to reach the object literal.
  while (
    ts.isAsExpression(current) ||
    ts.isSatisfiesExpression(current) ||
    ts.isParenthesizedExpression(current)
  ) {
    current = current.expression;
  }
  return current;
}

function getStoryExampleKeys(sourceText, filePath) {
  const sourceFile = ts.createSourceFile(
    filePath,
    sourceText,
    ts.ScriptTarget.Latest,
    true,
    ts.ScriptKind.TSX,
  );

  for (const stmt of sourceFile.statements) {
    if (!ts.isVariableStatement(stmt)) continue;
    const hasExport = stmt.modifiers?.some((m) => m.kind === ts.SyntaxKind.ExportKeyword);
    if (!hasExport) continue;

    for (const decl of stmt.declarationList.declarations) {
      const name = decl.name.getText(sourceFile);
      if (name !== 'storyExamples' || !decl.initializer) continue;

      const initializer = unwrapInitializer(decl.initializer);
      if (!ts.isObjectLiteralExpression(initializer)) {
        return [];
      }

      const keys = initializer.properties
        .map((prop) => {
          if (
            ts.isPropertyAssignment(prop) &&
            (ts.isIdentifier(prop.name) || ts.isStringLiteral(prop.name))
          ) {
            return prop.name.text;
          }
          return undefined;
        })
        .filter(Boolean);

      return keys;
    }
  }

  return [];
}

function sanitizeExportName(key) {
  const cleaned = key.replace(/[^a-zA-Z0-9]/g, '_');
  const parts = cleaned
    .split('_')
    .filter(Boolean)
    .map((part) => part[0]?.toUpperCase() + part.slice(1));
  const candidate = parts.join('') || 'Story';
  if (/^[0-9]/.test(candidate)) {
    return `Story${candidate}`;
  }
  return candidate;
}

function ensureDir(dir) {
  fs.mkdirSync(dir, { recursive: true });
}

function writeStory({ moduleSpecifier, relOutputPath, exampleKeys }) {
  const fallbackName = relOutputPath.replace(/\.stories\.tsx?$/, '');
  const fallbackTitle = `auto/${fallbackName}`;

  const exportsBlock = exampleKeys
    .map((key) => {
      const exportName = sanitizeExportName(key);
      return `export const ${exportName}: Story = {
  ...storyExamples['${key}'],
};`;
    })
    .join('\n\n');

  const content = `// AUTO-GENERATED by .rnstorybook/generate-stories.js. Do not edit manually.
import React from 'react';
import type { Meta, StoryObj } from '@storybook/react-native';
import * as Components from '@studio/ui/native';
import { storyMeta, storyExamples } from '${moduleSpecifier}';

const componentName = storyMeta.componentName ?? '${fallbackName}';
const Component =
  (Components as Record<string, React.ComponentType<any>>)[componentName] ??
  (() => null);

const meta: Meta<typeof Component> = {
  title: storyMeta.title ?? '${fallbackTitle}',
  component: Component,
  decorators: storyMeta.decorators,
  parameters: storyMeta.parameters,
};

export default meta;

type Story = StoryObj<typeof meta>;

${exportsBlock}
`;

  const outputPath = path.join(OUTPUT_ROOT, relOutputPath);
  ensureDir(path.dirname(outputPath));
  fs.writeFileSync(outputPath, content, 'utf8');
  console.log(`Generated ${path.relative(process.cwd(), outputPath)}`);
}

function main() {
  fs.rmSync(OUTPUT_ROOT, { recursive: true, force: true });
  ensureDir(OUTPUT_ROOT);

  const files = findExampleFiles(UI_NATIVE_ROOT);
  if (files.length === 0) {
    console.warn('No *.examples.ts[x] files found.');
    return;
  }

  for (const filePath of files) {
    const rel = path.relative(UI_NATIVE_ROOT, filePath);
    const source = fs.readFileSync(filePath, 'utf8');
    const exampleKeys = getStoryExampleKeys(source, filePath);
    if (exampleKeys.length === 0) {
      console.warn(`Skipping ${rel}: storyExamples missing or not an object literal.`);
      continue;
    }

    const relWithoutExt = rel.replace(/\.[^.]+$/, '');
    const moduleSpecifier = `${PACKAGE_PREFIX}/native/${relWithoutExt.replace(/\\/g, '/')}`;
    const relOutputPath = `${relWithoutExt.replace(/\\/g, '/')}.stories.tsx`;

    writeStory({ moduleSpecifier, relOutputPath, exampleKeys });
  }
}

main();
